# 7.5.2 힙스냅샷

# 7. 크롬 개발자 도구를 활용한 애플리케이션 분석

## 7.1 크롬 개발자 도구란?

실행시키는 방법

- 보기 → 개발자 도구
- 우측클릭 → 검사
- **단축키 : Windows: F12 / Mac: command + option + I**

개발자 도구에서 웹사이트를 제대로 디버깅 하고 싶다면

⇒ 시크릿 모드 or 프라이빗 모드라 불리는 개인정보 보호 모드에서 페이지와 개발자 도구를 여는 것을 권장

이유 : 브라우저에 설치돼 있는 각종 확장 프로그램 때문

- 확장 프로그램은 웹페이지 방문 시 확장 프로그램의 실행을 위해 전역 변수나 HTML 요소에 실제 웹앱이 제공하지 않은 다른 정보를 추가 할 수 있다.
- 개인정보 보호 모드에서는 확장 프로그램이 실행되지않아 순수하게 웹페이지와 관련된 정보만 확인 가능

![](https://velog.velcdn.com/images/juhee067/post/b5f45e4e-ae30-4822-a419-4a41c64895e4/image.png)

EX) 리액트 개발자 도구를 켰다면 전역 객체에 정보가 담겨 있는 것을 알 수 있는데 꺼져있다면 이 정보들은 찾을 수 없다.

## 7.2 요소 탭

크롬 개발자 도구에서 첫번째로 노출되는 탭은 “요소”

요소 : 현재 웹페이지를 구성하고 있는 HTML, CSS등의 정보를 확인 가능

## 7.2.1 요소 화면

요소화면 : 현재 HTML을 보는 것뿐만 아니라 직접 코드를 수정해서 웹페이지에서 어떻게 보이는지 확인가능

웹페이지 DOM을 직접적으로 수정하면

- 프로덕션으로 개발된 페이지에서 수정된 내용이 어떻게 보이는지 미리 확인 할 수 있어 편리
- 개발 모드에서도 리액트 코드를 수정해 핫 리로딩을 거치지않아도 확인할 수 있으므로 빠른 작업이 가능

핫 리로딩 :

개발자가 소스 코드를 수정할 때 애플리케이션을 다시 로드하지 않고도 변경 사항을 즉시 반영하는 기능
이는 코드 수정 후 새로고침 없이 애플리케이션의 상태를 유지하면서 변경 사항을 빠르게 확인한다.

만약 배너와 같이 코드에 의해 클래스나 속성값이 동적으로 제어되는 DOM이 있다면 요소의 중단점을 사용해 디버깅 할 수 있다.

- 먼저 디버깅하고 싶은 요소를 선택하고 마우스 오른쪽 버튼을 클릭한 후 중단 위치를 선택하고 중단을 원하는 옵션을 클릭한다.

![](https://velog.velcdn.com/images/juhee067/post/1b07dd94-af3f-4287-bf68-3652a7649615/image.png)

- 중단 위치를 설정해 두면 중단과 관련된 작업이 일어날 때마다 브라우저가 렌더링을 중단하고 해당 요소 변경을 일으킨 소스 코드를 보여준다.

⇒ 따라서 리액트에서 해당 요소의 클래스를 수정하는 코드를 찾아보면 된다는 실마리를 얻을 수 있다.

## 7.2.2 요소 정보

![](https://velog.velcdn.com/images/juhee067/post/9fa3f289-9ccb-4881-9f97-bef721628669/image.png)

이벤트 리스너 :

![](https://velog.velcdn.com/images/juhee067/post/11a61764-3d36-4ace-8f2c-2395e98d637c/image.png)

- 현재 요소에 부착된 각종 이벤트 리스너 확인
- 상위 버튼을 체크 해제하면 딱 해당 요소에 명확하게 부착된 이벤트만 볼 수 있다.
- 이벤트 버블링 등으로 이벤트를 발생시키는 경우에는 확인 불가능

속성 :

![](https://velog.velcdn.com/images/juhee067/post/05c3fa14-fa43-460e-a9b4-55e875368bf0/image.png)

- 해당요소가 지닌 모든 속성값
- 기본적으로 js에서 해당 DOM으로 .attributes를 실행했을 때 나오는 결과와 비슷하지만
  ⇒ .attributes는 직접 할당된 값만 나오는 반면 속성탭에는 모든 값이 나온다는 차이가 있다.
- 해당 요소가 가지고 있는 모든 값을 확인하고 싶다면 속성 탭을 확인해보자

접근성 :

![](https://velog.velcdn.com/images/juhee067/post/e67ed1d9-e79f-4853-8636-18877f5ae076/image.png)

웹 이용에 어려움을 겪는 장애인, 노약자를 위한 스크린리더기 등이 활용하는 값

## 7.3 소스 탭

웹 앱을 불러오기 위해 실행하거나 참조된 모든 파일을 확인

유용하게 사용하는 방법 :

디버깅하고 싶은 파일을 직접 열어보자.

![](https://velog.velcdn.com/images/juhee067/post/eb9062ce-44a9-4640-ba50-30f8f2e62dfc/image.png)

⇒ 프로덕션 모드의 경우 파일이 모두 압축돼 있기에 디버깅하기가 매우 불편하다. 개발모드에서는 유용

프로덕션 모드 : 소프트웨어나 웹 애플리케이션을 실제 사용자에게 제공하기 위해 최적화된 상태

### Q. 소스 탭의 장점은 그저 파일을 볼 수 있는 것? x

앞서 요소 탭에서 DOM 중단점을 만들어 DOM이 변경되는 과정을 디버깅해 볼 수 있었던 것과 마찬가지로 여기서도 소스 중단점을 생성해 js 실행을 중단 시키고 디버깅이 가능하다.
![](https://velog.velcdn.com/images/juhee067/post/f7c78589-fa2b-459f-b807-98245e6517b2/image.png)

![](https://velog.velcdn.com/images/juhee067/post/350bc250-f930-483b-967c-325302a1468a/image.png)

⇒ 이는 코드에 debugger를 선언하는 것과 동일한 역할을 한다.

아래 예시처럼 스크립트 내에 `debugger` 명령어를 적어주면 중단점을 설정한 것과 같은 효과를 봅니다.

```bash
function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- 여기서 실행이 멈춥니다.

  say(phrase);
}
```

debugger 명령어를 사용하면 브라우저를 켜 개발자 도구를 열고 소스 코드 영역을 띄워 중단점을 설정하는 수고를 하지 않아도 됩니다.

### **리액트에서 내보내는 useEffect에 중단점을 걸어 디버깅해보자.**

![](https://velog.velcdn.com/images/juhee067/post/1e650ec9-fa42-4914-b54d-56bba33a2695/image.png)

중단점을 생성해 확인한 결과, create라 선언된 useEffect를 만드는 함수, 그리고 deps라고 선언된 의존성 배열 등을 확인 할 수 있다.

![](https://velog.velcdn.com/images/juhee067/post/d2b90607-b0e7-4a60-82e5-089423eb4b41/image.png)

⇒ 사용 중인 라이브러리에서 버그가 의심되는 지점을 디버깅하거나 실제로 소스 코드상에서 어떤 식으로 작동하는지 확인하고 싶을 때 매우 유용

소스 탭 오른쪽에 제공하는 정보와 기능은 무엇인지 알아보자.

![](https://velog.velcdn.com/images/juhee067/post/0f0ab8cc-3573-4b34-abac-0d86adc90726/image.png)

watch : 확인하고자 하는 변수를 선언

- 해당 변수의 정보를 확인할 수 있는 메뉴다.
- 왼쪽에서 제공하는 변수 외에 디버깅 시점에서 특정 변수의 값을 알고 싶다면 이 감시를 활용하자.

- 감시로 확인 할 수 없는 값이면 아래와 같이 표시된다.

![](https://velog.velcdn.com/images/juhee067/post/a6a61bee-c6a5-4983-901d-ad644f0428e3/image.png)

Breakpoint : 현재 웹에서 추가한 중단점 확인

- 현재 열려 있는 파일 뿐만 아니라 웹 전체에 걸쳐 소스탭에서 추가한 모든 중단점을 확인 가능

Scope : 범위는 이름 그대로 현재 중단점에서의 스코프를 의미

![](https://velog.velcdn.com/images/juhee067/post/730dacf0-fdf3-4241-9eac-acf7d920d42d/image.png)

- 로컬은 현재 로컬 스코프를 의미, 이 스코프에서 접근할 수 있는 값을 확인
  ⇒ 이 밖에도 클로저, 전역 스코프 등을 확인 할 수 있다.

호출 스택 : 현재 중단점의 콜스택을 확인 할 수 있다.
⇒ 이는 js 코드가 실행되며 생성되는 실행 콘텍스트가 어떻게 저장되어 현재 어떤 모습을 하고 있는지 직접 볼 수 있다.

전역리스너 : 현재 전역 스코프에 추가된 리스너 목록을 확인할 수 있다.

XHR/가져오기, DOM,이벤트 리스너, CSP 위반 중단점 : 소스의 중단점 이외에 다양한 중단점을 확인 가능

## 7.4 네트워크 탭

네트워크 탭에는 해당 웹을 접속하는 순간부터 발생하는 모든 네트워크 관련 작동이 기록된다.

웹에서 자주 사용하는 HTTP요청부터 웹 소켓에 이르기까지, 웹페이지가 외부 데이터와 통신하는 정보를 확인하고 싶다면 네트워크 탭을 참조하면 된다.

![](https://velog.velcdn.com/images/juhee067/post/86ec4c57-113b-432d-82d3-3007a4649305/image.png)

- 탭으로 보고 싶은 네트워크 요청 종류를 필터링할 수 있으며, 기타 다른 체크박스를 선택해 보고 싶은 네트워크 종류를 제한할 수 있다.
- 그리고 왼쪽에는 실제 해당 페이지를 불러오는 과정에서 발생한 네트워크 요청을 볼 수 있다.
- 이 네트워크 요청을 통해 페이지가 로딩되는 과정을 대략적으로 확인해 볼 수도 있다.
- 웹은 최초에 HTML을 다운로드하고 HTML을 파싱하는 과정에서 만난 js를 다운로드한다.
- 그리고 이페이지는 개발자 모드로 실행됐기에 웹 소켓을 통해 핫 리로딩되는 것을 확인할 수 있다.
- 하단에는 페이지를 불러오는 기간 동안 발생한 총 요청건수와 총 다운로드한 업로드 리소스의 크기를 확인 할 수 있다.
  ![](https://velog.velcdn.com/images/juhee067/post/7bd20251-8967-4803-8f2a-99ad81b1ebc4/image.png)
  ⇒ 생각 이상으로 리소스 크기가 크다면 gzip이나 brotli를 적절히 활용해 리소스를 압축하거나 이미지가 있다면 이미지를 최적화할 필요도 있다.
- 스크린샷 기능
  ![](https://velog.velcdn.com/images/juhee067/post/da7506e9-e857-46b3-9530-89fe7da39fec/image.png)

네트워크 요청 흐름에 따라 웹페이지가 어떻게 로딩되고 있는지 확인 가능

네트워크 탭을 통해 집중적으로 확인해 봐야하는 점은 다음과 같다.

- 불필요한 요청 또는 중복되는 요청이 없는지
- 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
- 리소스를 불러오는 속도는 적절한지 또는 너무 속도가 오래 걸리는 리소스는 없는지
- 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지

## 7.5 메모리 탭

메모리 탭에서는 현재 웹이 차지하고 있는 메모리 관련 정보를 확인할 수 있다.

앱에서 발생하는 메모리 누수, 속도 저하, 혹은 웹 프리징 현상을 확인 할 수 있는 유용한 도구이다.

![](https://velog.velcdn.com/images/juhee067/post/62f738c3-4f82-4bbd-b839-fdf8a30c6889/image.png)

- 메모리 탭을 열면 리액트 개발 도구의 프로파일과 비슷하게 프로파일링 작업을 거쳐야 원하는 정보를 볼 수 있음을 확인할 수 있다.
- 다른 크롬 개발자 도구인 요소나 다른 탭과는 다르게 메모리 탭 그 자체만으로는 아무것도 할 수 없다.
- 프로파일 유형이 크게 세가지가 있다.
  - 힙 스냅샷 : 현재 메모리 상황을 사진 찍듯이 촬영 한다.
    현재 시점의 메모리 상황을 알고 싶다면 힙 스냅샷을 활용하자.
  - 타임라인의 할당 계측 : 현재 시점의 메모리 상황이 아닌, 시간의 흐름에 따라 메모리 변화를 살펴보고 시다면 타임라인의 할당 계측을 활용하자.
    ⇒ 주로 로딩이되는 과정의 메모리 변화 or 페이지에서 어떠한 상호작용을 했을 때 메모리의 변화 과정을 알고 싶을 때 사용
  - 할당 샘플링 : 메모리 공간을 차지하고 있는 자바스크립트 함수를 볼 수 있다.
    힙 : 동적으로 할당된 메모리 영역. 이 영역은 프로그램 실행 중에 동적으로 할당되고 해제되는 데이터를 저장하기 위해 사용된다.

### 7.5.1 자바스크립트 인스턴스 VM 선택

현재 실행 중인 js VM인스턴스를 확인 할 수 있다.

![](https://velog.velcdn.com/images/juhee067/post/e131f08d-cb3f-4e2b-b79c-11a8a74571fb/image.png)

1. 디버깅하고 싶은 JS VM 환경을 선택하면 된다.
2. 환경별 힙 크기를 볼 수 있는데, 실제 해당 페이지가 js 힙을 얼마나 점유하고 있는지 나타낸다
   ⇒이 크기는 js실행에 따라 실시간으로 바뀐다.
3. 이 크기만큼 사용자의 브라우저에 부담을 주기 때문에 불필요하게 크기가 늘어나지 않는지 확인 가능하다.

### 7.5.2 힙 스냅샷

현재 페이지의 메모리 상태를 확인해 볼 수 있는 메모리 프로파일 도구

- 힙 스냅샷을 촬영하는 시점을 기준으로 마치 사진으로 촬영하듯 메모리 현황을 보여준다.

ex)

1. 컴포넌트 외부에 있는 배열에 천만 개의 랜덤한 값을 push하는 코드를 작성한다.

```bash
const DUMMY_LIST = [];

export default function App() {
  function handleClick() {
    // 이 부분에서 오타와 문법 오류를 수정합니다.
    Array.from({ length: 10_000_000 }).forEach((_, idx) => DUMMY_LIST.push(Math.random() * idx));
    alert('complete!');
  }

  return <button onClick={handleClick}>BUG</button>;
}

```

- 먼저 페이지에 진입하고 페이지 로딩이 완료되면 힙 스냅샷 촬영을 한 번 수행한다.

![](https://velog.velcdn.com/images/juhee067/post/06573982-627f-4019-bf65-d9eba6f6dca5/image.png)

- 컴포넌트가 하나 뿐이지만, 메모리에 많은 정보들이 존재한다.
- ⇒ 리액트 기반 앱이 기본적으로 차지하는 내용, 그리고 window 객체 등 브라우저가 차지하는 내용이 존재하기 때문

1. 여기서 Bug버튼을 한 번 더 클릭해 DUMMY_LIST의 다량의 데이터가 push되게 한 다음, 촬영해보자
   - 기존의 3.9MB에서 123MB로 증가
     ![](https://velog.velcdn.com/images/juhee067/post/6b7e4464-b768-4b4c-8ed9-2a61b6503581/image.png)

![](https://velog.velcdn.com/images/juhee067/post/92999434-2985-49f3-a6be-e60647a52113/image.png)

1.  차이의 원인을 정확하게 파악하기 위해 모든 객체 메뉴를 클릭하고
    스냅샷1에서 스냅샷 2 사이에 할당된 객체를 클릭해 얕은 크기 항목을 기준으로 내림차순으로 정렬해보자.

        ![](https://velog.velcdn.com/images/juhee067/post/ecf5fd77-cf9e-45bd-b5fe-4951983471cf/image.png)

        - 두 스냅샷 간 사이에 일어났던 유저 인터랙션, 즉 버튼 클릭으로 인해 이러한 메모리 사용량 차이가 발생

        ![](https://velog.velcdn.com/images/juhee067/post/80e91d10-1518-4897-a014-918bfdf9e879/image.png)


        - 메모리를 크게 차지하고 있는 것이 객체라는 점, 그리고 이 액션이 handleClick이라는 함수를 통해 빚어졌다는 것도 파악 할 수 있었다.
        - 해당 배열의 값도 확인 가능
        ⇒ 해당 객체를 우측클릭 후 전역 변수로 저장하면 해당 변수 값이 전역 변수에 저장된다
        window.temp1에 기록 됐으며, 실제 값 또한 console에서 확인 가능하다.

        ![](https://velog.velcdn.com/images/juhee067/post/83b9189b-d2bf-4e04-93e0-704112dcdce7/image.png)

        스냅샷 촬영을 제대로 활용하기 위한 방법

        : 하나의 스냅샷을 파악하기 보단 스냅샷을 두개 이상을 촬영한 다음, 그 차이만 비교하는 것이 훨씬 수월하다.

        ![](https://velog.velcdn.com/images/juhee067/post/5cf97cce-4363-42c4-86c4-595628300815/image.png)


        이유 : 앞서 아무것도 없는 페이지라도 리액트와 브라우저가 웹페이지 실행을 위해 많은 것을 준비해두기 때문이다. html만 있는 페이지에서 스냅샷 촬영을 해도 정말 다양한 내용이 담겨있을 것이다.

        이 웹에는 기본적으로 제공되는 window 전역변수 내의 정보나 시스템이 가져야할 기본 정보 등 다양한 기초 정보가 포함돼 있기 때문이다. 그렇기에 하나의 스냅샷으로 정확하게 디버깅하는 것은 어렵다.

        그리고 스냅샷을 활용하면 useMemo나 useCallback과 같은 의존성이 있는 값들이 정말로 렌더링 사이에 그대로 유지되는지 육안으로 직접 확인할 수 있다.

        ✅ 생각보다 스냅샷 정보에 많은 내용이 담겨있기에 개발자가 원하는 메모리 누수 정보를 찾는 건 쉽지않다.

        힙 스냅샷을 통해 메모리 누수 정보를 확인하기 위해서는 메모리 누수가 발생하는 것으로 예상되거나 혹은 위험이 존재할 것 같은 스크립트 전후로 내용을 촬영해 비교하는 것이 좋다.

        ### 7.5.3 타임라인 할당 계측

        힙 스냅샷은 해당 시점의 메모리 내용만 촬영하는 프로파일링 기법이지만, 타임라인 할당 계측은 시간의 흐름에 따라 메모리 변화를 확인할 수 있는 기능이다.

        ⇒ 시간의 흐름에 따라 메모리의 변화를 모두 기록하기에 상대적으로 많은 부담이 발생한다.

        ```jsx
        import { useState } from 'react';

        export default function App() {
          const [number, setNumber] = useState(0);
          const [list, setList] = useState<Array<string>>([]);

          const handleClick = () => {
            const newNumber = number + 1;
            setNumber(newNumber);

            setList((prev) => [
              ...prev,
              ...Array.from({ length: newNumber * 3000 }).map((_, index) => `${index + number * 3000}`)
            ]);
          };

          return (
            <>
              <button onClick={handleClick}>+</button>
              <ul>
                {list.map((item, index) => (
                  <li key={`${item}_${index}`}>{item}</li>
                ))}
              </ul>
            </>
          );
        }

        ```

        버튼을 누를 때마다 3000,6000,9000개씩 배열에 새로운 아이템이 생긴다.
        이 배열을 모두 DOM에 그려야한다.

        ![](https://velog.velcdn.com/images/juhee067/post/56899d16-c9d0-4ece-bc3b-4db6f7bb6b23/image.png)

        그 결과, DOM을 그리기 위해 리액트 1:1 구조로 생성하는 FiberNode와 해당 배열을 담아야하는 array가 엄청난 크기로 커진 것을 알 수 있다.

        ![](https://velog.velcdn.com/images/juhee067/post/2ec67755-0a8b-47d4-93b6-f90a5e922dad/image.png)

        해당 객체가 어떤 값을 가지고 있는지 살펴보려면 화살표를 누르면된다.

        ![](https://velog.velcdn.com/images/juhee067/post/39dcfba3-fa3e-45d7-bb66-ca70eede2195/image.png)

        타임라인 할당 계측의 또 다른 장점은 기간을 좁혀서 확인해 볼 수 있다는 것이다.

        상단 그래프에서 검색을 원하는 범위를 좁히면 해당 기간에 메모리에 할당된 내용만 골라서 볼 수 있다.

✅ 이처럼 시간의 흐름에 따른 메모리 점유율을 자세히 알고 싶다면 타임라인 할당 계측을 활용하자.

### 7.5.4 할당 샘플링

시간의 흐름에 따라 발생하는 메모리 점유를 확인할 수 있다는 점에서 타임라인 할당 계측과 비슷하지만

js 실행 스택별로 분석할 수 있고, 이 분석을 함수 단위로 한다는 차이점이 있다.

![](https://velog.velcdn.com/images/juhee067/post/413939ce-5234-49f3-881a-334b95bef121/image.png)

addDummy 함수가 문제다.

⇒ 문제되는 함수 뿐만아니라 오른쪽의 파일명을 누르거나 우측클릭 후 소스 패널에 표시를 선택해 해당 함수가 어느 파일에서 어떻게 정의됐는지도 확인 가능하다.

![](https://velog.velcdn.com/images/juhee067/post/71f200e1-d9fb-4ada-bccf-ac49cf4d0b68/image.png)

✅ 이처럼 할당 샘플링은 타임라인 할당 계측과 유사하지만 프로파일링할 때 브라우저에 주는 부담을 최소화할 수 있어 장시간에 걸쳐 디버깅을 수행해야 할 때 유리하다.

만약 메모리 누수가 짐작되지만 정확히 어디에서 발생하는지 확인하기 어려워 힙 스냅샷을 촬영해 비교하기 어려운 경우, 오랜 기간 메모리 누수가 의심되어 프로파일링을 장시간 수행해야 하는 경우에 해당 샘플링을 활용하기 좋다.

## 7.6 Next.js 환경 디버깅

**Q. 만약 서버 사이드 렌더링을 수행하는 자바스크립트 환경에서 메모리 누수가 발생한다면 어떻게 될까?**

: 서버 자체에 부담이 발생할 것이고, 서버의 부담은 곧 모든 사용자가 서비스를 사용할 수 없는 심각한 상황을 초래하게 될 것이다.

놀랍게도 서버 환경도 동일하게 크롬 개발자 도구로 디버깅이 가능하다.

### 7.6.1 Next.js 프로젝트를 디버그 모드로 실행하기

가장 먼저 할 일은 next.js 프로젝트를 디버그 모드로 실행한다

```jsx
"dev":NODE_OPTIONS='--inspect' next dev
```

NODE_OPTIONS='--inspect'라는 인수와 함께 next dev를 실행하면 다음과 같이 디버거가 활성화되면서 디버그 모드가 켜진 것을 확인 할 수 있다.

![](https://velog.velcdn.com/images/juhee067/post/d55b7ccf-d85d-49ca-9dd4-0414d54d71c2/image.png)

이렇게 웹 소켓 주소가 나타나면 디버거에 연결된 준비가 된 것이다.

그 다음 크롬 브라우저에서 chrome://inspect로 이동하자.

![](https://velog.velcdn.com/images/juhee067/post/4e357871-cf9d-4ea5-bbca-8d1298261a61/image.png)

여기서 Open dedicated DevTools for Node를 클릭하면 아래와 같은 개발자 도구가 나타난다.

![](https://velog.velcdn.com/images/juhee067/post/8c367ae3-9d40-41b4-9c3b-3cf2caf0c486/image.png)

### 7.6.2 Next.js 서버에 트래픽 유입시키기

서버사이드렌더링과 같이 서버에서 제공되는 서비스의 경우 서버를 실행한 뒤 사용자가 서서히 유입되면서 메모리 누수가 발생하는 경우가 많다.

⇒ 서버에 직접 트래픽을 발생시켜서 확인하는 편이 제일 확실하다.

이제 사용자의 트래픽이 서버로 몰리는 상황을 시뮬레이션해보자.

다른 컴터를 이용해 접속하는 것보다 더 편리한 방법은 바로 오픈소스 도구인 ab를 사용하자.

ab : 아파치 재단에서 제공하는 웹서버 성능 검사 도구로, HTTP 서버의 성능을 벤치마킹할 수 있는 도구다.

```jsx
 ab -k -c 50 -n 10000 "http://127.0.0.1:3000/"
```

이 명령어는 "http://127.0.0.1:3000/"을 향해 한 번에 50개의 요청을 총 10,000회 시도한다.

로컬에서 테스트 할 경우 주소를 localhost로 정상적으로 실행되지 않으니 반드시 IP나 올바른 주소를 기재해야한다.

이 명령어를 실행시키면 아래와 같이 요청이 된다.

![](https://velog.velcdn.com/images/juhee067/post/dd58f115-b93c-469a-b829-dcd99327e3e4/image.png)

ab를 사용하면 단순히 요청을 수행하는 것뿐만 아니라 요청으로 부터 응답 받는 데 걸린 시간, 바이트 크기등 다양한 정보를 확인 할 수 있다.
