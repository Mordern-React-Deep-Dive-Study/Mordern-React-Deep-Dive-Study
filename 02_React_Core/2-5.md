# 2.5. 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

## 2.5.1. 주장 1 : 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자

- **메모이제이션도 어디까지나 비용이 드는 작업**
    - 값을 비교하고 렌더링 또는 재계산이 필요한지 확인하는 작업
    - 이전에 결과물을 저장해두었다가 다시 꺼내야 하는 작업
- **최종 결론 : 일단 애플리케이션을 어느정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다**

## 2.5.2. 주장 2 : 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자

- 리액트 애플리케이션의 규모가 커지고, 개발자는 많아지고, 컴포넌트의 복잡성이 증가하는 현실적인 대규모 프로젝트의 상황에서 일일히 확인하고 최적화하는 것이 옳을까? <br>
-> 그렇다면 일단  memo로 감싼뒤에 생각해 보는건 어떨까?

- 오히려 최적화를 못해서 memo를 모든 곳에 감쌌을때 역으로 지불해야하는 비용을 생각해보자
    - 메모이제이션을 위해서는 이전 렌더링 결과물을 저장해두고, 리렌더링 할 필요가 없다면 다시 꺼내서 사용해야 한다. 
    **하지만 어차피 리액트의 기본적인 알고리즘 때문에 이전 결과물은 어떻게든 저장해두고 있다.**
    - 따라서 우리가 잘못된 memo로 지불해야하는 비용은 바로 props에 대한 얕은 비교 뿐인 것이다.
    - 물론 props에 대한 얕은 비교도 무시할 수 없지만, memo를 하지 않았을 때 발생할 수 있는 문제의 위험 비용이 더 크다는 사실은 변치 않는다.
        - 렌더링을 함으로써 발생하는 비용
        - 컴포넌트 내부의 복잡한 로직의 재실행
        - 위 두가지고 모든 자식 컴포넌트에서 반복 발생
        - 리액트가 구 트리와 신규 트리 비교
    - useMemo와 useCallback을 사용하지 않는다면?
        - 두 함수를 사용해 의존성 배열 비교 및 필요할 때만 값을 재계산하는 과정
        - 매번 함수를 재생성하고, 매번 값을 재계산하는 과정
    - 메모이제이션은 컴포넌트 자신의 리렌더링뿐만 아니라 이를 사용하는 쪽에서도 변하지 않는 고정된 값을 사용할 수 있게 해준다.

- **최종 결론 : 메모이제이션을 하지않았을 때보다 했을때 더 많은 이점이 있다. 메모이제이션을 실수했을 때 치러야 할 위험비용이 높다.**

## 2.5.3. 결론 및 정리

1. 아직 리액트를 배우고 있거나 리액트를 깊이 이해하고 싶고, 이를 위해 시간을 투자할 여유가 있다 <br>
**→ 주장 1 처럼 어느 지점에서 성능낭 이점을 누릴 수 있는지 살펴보며 메모이제이션의 최적화를 적용해 보도록 하자**

<br>

2. 현업에서 리액트를 사용하고 있거나 실제로 다룰 예정이지만 성능에 대해 깊게 연구해 볼 시간적 여유가 없는 상황이다<br>
**→ 일단 의심스러운 곳에는 먼저 모두 다 적용해 볼 것을 권장한다.
일반적으로 props에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비싸다.**