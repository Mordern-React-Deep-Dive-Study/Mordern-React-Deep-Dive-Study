## 2.2 가상DOM과 리액트 파이버

리액트의 특징중 가장 많이 언급되는 것 중 하나가 실제 DOM이 아니라 가상 DOM을 사용한다는 것인데, 이 특징에 대해서 알아보자

### 2.2.1 DOM과 브라우저 렌더링 과정

#### DOM이란 무엇인가?

: DOM은 웹페잊에 대한 인테페이스로 브라우저가 웹페이지의 콘텐츠와 구조를 어떻게 보여줄지에 대한 정보를 담고 있다.

#### 브라우저가 웹사이트 접근 요청을 받고 화면을 그리는 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일은 다운로드
2. 브라우저의 랜더링 엔진은 HTML을 파싱해 DOM 노드로 구성된 트리 (DOM)을 만든다
3. 2번과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드
4. 브라우저의 렌더링 엔진은 이 CSS 파싱해 CSS 노드로 구성되 트리(CSSOM)을 만든다.
5. 브라우저는 2번에서 만든 DOM노드를 순회하는데 여기서 모든 노드를 방문하는 것이 아니고 사용자 눈에 보이는 노드만 방문
   6.5번에서 제외된 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 여기서 발견한 CSS 스타일 정보를 이 노드에 적용

이렇게 모든 단계를 거친 최종 출력물을 웹 애플리케이션의 모든 콘탠츠와 스타일 정보를 갖게 됨

> ex)

```
#text {
	background-color: red;
	color: white;
}
<!DOCTYPE html>
<html>
  <head>
    <link rel="stylesheet" />
    <title>Hello React</title>
  </head>
  <body>
    <div style="width: 100%;">
      <div id="text" style="width: 50%">Hello World!</div>
    </div>
  </body>
</html>
```

1. HTML을 다운로드한다. 다운로드와 함께 HTML을 분석하기 시작한다.
2. 스타일시트가 포함된 link 태그를 발견해 style.css를 다운로드한다.
   3.body 태그 하단의 div는 width: 100%이므로 뷰포트로 좌우 100% 너비로 잡는다.
   4.3번 하단의 div는 width: 50%, 즉 부모 너비를 50%를 너비로 잡아야 하므로 전체 영역의 50%를 너비로 잡는다.
   5.2번에서 다운로드한 CSS에 id="text"에 대한 스타일 정보를 결합한다. 6.화면에 HTML 정보를 그리기 위한 모든 정보가 준비됐으므로 위 정보를 바탕으로 렌더링을 수행한다.

### 2.2.2 가상 DOM의 탄생 배경

- 브라우저가 웹페이지를 렌더링하는 과정은 매우 복잡하고 많은 비용이 든다
- 요즘 대다수의 앱은 렌더링된 이후 정보를 보여주는데 그치지 않고 사용자의 인터랙션을 통해 다양한 정보를 노출
  => 인터랙션에 따라 DOM은 계속해서 변경될 것이고, 특히 SPA(Single Page Application)에서는 더욱 더 심할 것이다. 이는 DOM을 관리하는 비용 또한 증가할 것이며 모든 인터랙션을 추적하는 것은 개발자에게 힘든 일
  => 이를 해결하기 위해 나온 것이 가상 DOM

가상 DOM

- 일단 메모리에 저장하고 리액트가 실제 변경에 대한 준비가 완료됐을 때 실제 브라우저의 DOM에 반영
- 모든 렌더링 과정을 브라우저에서 하는 게 아닌 메모리에서 계산하고 최종 결과를 브라우저 DOM에 보여준다면, 렌더링 과정을 최소화하여 비용을 줄일 수 있고, 브라우저와 개발자의 부담을 덜 수 있다.

### 2.2.3 가상DOM을 위한 아키텍처, 리액트 파이버

#### 리액트 파이버란?

: 가상 DOM과 실제 DOM을 비교해 변경 사항을 수집하며, USER에 의한 인터랙션으로 두 DOM이 차이가 생기면, 파이버를 기준으로 화면에 렌더링을 요청하는 역할, 가상 DOM을 관리하고 렌더링 과정 최적화를 하는 역할

#### 리액트 파이버의 역할

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고, 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

자바스크립트의 특징인 싱글 스레드로 인한 진행과정을 동기적(스택 알고리즘)으로 처리하기에는 너무 비효율적이여서, 리액트 파이버는 비동기적으로 처리해 사용자 인터랙션에 따른 동시 다발적인 이벤트와 애니메이션을 효율적으로 처리한다

#### 리액트 파이버 트리

: 파이브 트리는 사실 리액트 내부에서 2개가 존재한다. 하나는 현재 모습을 담은 파이버 트리고, 다른 하나는 작업 중인 상태는 나타내는 workInProgress 트리다.

#### 일반적인 파이버 노드의 생성 흐름

1. 리액트는 beginWork() 함수를 실행해 파이버 작업을 수행하는데, 더 이상 자식이 없는 파이버를 만날 때까지 트리 형식으로 시작된다.
2. 1번에서 작업이 끝난다면 그다음 completeWork() 함수를 싱행해 파이버 작업을 완료한다.
3. 형제가 있다면 형제로 넘어간다.
4. 2번, 3번이 모두 끝난다면 return으로 돌아가 자신의 작업이 완료됐음을 알린다

```
// ex)
<A1>
  <B1>안녕하세요</B1>
  <B2>
    <C1>
      <D1 />
      <D2 />
    </C1>
  </B2>
  <B3 />
</A1>
```

    1. A1의 beginWork()가 수행된다.
    2. A1은 자식이 있으므로 B1로 이동해 beginWork()를 수행한다.
    3. B1은 자식이 없으므로 completeWork()가 수행됐다. 자식은 없으므로 형제(sibling)인 B2로 넘어간다.
    4. B2의 beginWork()가 수행된다. 자식이 있으므로 C1로 이동한다.
    5. C1의 beginWork()가 수행된다. 자식이 있으므로 D1로 이동한다.
    6. D1의 beginWork()가 수행되고, 자식이 없으므로 형제(sibling)인 D2로 넘어간다.
    7. D2의 beginWork()가 수행되고, 자식이 없으므로 completeWork()가 수행됐다.
    8. D2는 자식도 형제도 없으므로, 위로 이동해 C1, B2 순으로 completeWork()를 호출한다.
    9. B2는 형제(sibling)인 B3으로 이동해 beginWork()를 수행한다.
    10. B3의 completeWork()가 수행되면 반환해 상위로 타고 올라간다.
    11. A1의 completeWork()가 수행된다.
    12. 루트 노드가 완성되면 commitWork()가 수행되고 이 중 변경 사항을 비교해 업데이트가 필요한 변경사항이 DOM에 반영된다.

setState로 인한 업데이트가 발생하면, 이미 리액트에는 앞서 만든 current 트리가 존재하고 setState로 인한 업데이트 요청을 받아 workInProgress 트리를 다시 빌드하기 시작한다.
이미 파이버가 존재하므로 새로 생성하지 않고 기존의 파이버에서 업데이트된 props를 받아 파이버 내부에서 처리한다.
-> 새로운 파이버를 만드는 것은 리소스 낭비라고 볼 수 있다. 따라서 기존의 파이버 객체를 재활용하여 내부 속성값만 초기화하거나 바꾸는 형태로 트리를 업데이트한다
